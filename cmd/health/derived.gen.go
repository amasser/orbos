// Code generated by goderive DO NOT EDIT.

package main

// deriveCompose composes functions f0, f1 and f2 into one function, that takes the parameters from f0 and returns the results from f2.
func deriveCompose(f0 func(string) (splitArgsTuple, error), f1 func(splitArgsTuple) (parsedArgsTuple, error), f2 func(parsedArgsTuple) (string, error)) func(string) (string, error) {
	return func(v_0_0 string) (string, error) {
		v_1_0, err0 := f0(v_0_0)
		if err0 != nil {
			return "", err0
		}
		v_2_0, err1 := f1(v_1_0)
		if err1 != nil {
			return "", err1
		}
		v_3_0, err2 := f2(v_2_0)
		if err2 != nil {
			return "", err2
		}
		return v_3_0, nil
	}
}

// deriveTupleSplitArgs returns a function, which returns the input values.
// Since tuples are not first class citizens in Go, this is a way to fake it, because functions that return tuples are first class citizens.
func deriveTupleSplitArgs(v0 string, v1 string) func() (string, string) {
	return func() (string, string) {
		return v0, v1
	}
}

// deriveTupleParseArgs returns a function, which returns the input values.
// Since tuples are not first class citizens in Go, this is a way to fake it, because functions that return tuples are first class citizens.
func deriveTupleParseArgs(v0 string, v1 int) func() (string, int) {
	return func() (string, int) {
		return v0, v1
	}
}
